#!/usr/bin/env python3
"""
Generate data/metadata/labels.py by mapping raw CSV labels to canonical labels.
Implements normalization and fuzzy matching to handle slight variations without cross-team mapping.
Also handles the absence of an existing labels.py and warns on unmatched raw labels.
"""

import re
import csv
import sys
from pathlib import Path
from difflib import get_close_matches
import importlib.util

# ─── Project root and paths ──────────────────────────────────
BASE_DIR = Path(__file__).resolve().parent.parent
CSV_PATH = BASE_DIR / "data" / "metadata" / "clip_index.csv"
OUT_MODULE = BASE_DIR / "data" / "metadata" / "labels.py"
SIMILARITY = 0.6  # cutoff for fuzzy matching


def load_canonical_labels():
    """
    Load existing label_list from labels.py if it exists, else return empty list.
    """
    if OUT_MODULE.exists():
        spec = importlib.util.spec_from_file_location("labels", str(OUT_MODULE))
        labels_mod = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(labels_mod)
        return getattr(labels_mod, "label_list", [])
    else:
        print(
            f"[INFO] No existing labels.py at {OUT_MODULE}, starting with empty canonical list."
        )
        return []


def normalize(lbl: str) -> str:
    """
    Normalize a raw label: strip, uppercase, unify dashes/slashes, collapse spaces.
    """
    lbl = lbl.strip().upper()
    lbl = re.sub(r"[–—\-]", "/", lbl)  # dash → slash
    lbl = re.sub(r"\s*[/,]\s*", " / ", lbl)  # unify separators
    lbl = re.sub(r"\s+", " ", lbl)  # collapse whitespace
    return lbl


def build_label_map(raw_labels, canonical_labels, cutoff=SIMILARITY):
    """
    Map raw labels to canonical labels:
      1) Exact normalized match
      2) Space-insensitive normalized match
      3) Fuzzy match on raw string
    Falls back to identity if no good match.
    """
    # Pre-normalize canonical labels
    canon_norm = {normalize(cl): cl for cl in canonical_labels}
    label_map = {}

    for raw in raw_labels:
        nrm = normalize(raw)
        # 1) Exact normalized match
        if nrm in canon_norm:
            label_map[raw] = canon_norm[nrm]
            continue
        # 2) Space-insensitive match
        for cn_norm, orig in canon_norm.items():
            if nrm.replace(" ", "") == cn_norm.replace(" ", ""):
                label_map[raw] = orig
                break
        else:
            # 3) Fuzzy match on raw label
            matches = get_close_matches(raw, canonical_labels, n=1, cutoff=cutoff)
            if matches:
                label_map[raw] = matches[0]
            else:
                # no good match: map to itself
                label_map[raw] = raw
    return label_map


def main():
    # Load or initialize canonical labels
    canonical_labels = load_canonical_labels()

    # Ensure CSV exists
    if not CSV_PATH.exists():
        print(f"[ERROR] CSV not found at {CSV_PATH}", file=sys.stderr)
        sys.exit(1)

    # 1) Gather raw labels from CSV
    raw_set = set()
    with CSV_PATH.open(newline="") as f:
        reader = csv.DictReader(f)
        for row in reader:
            raw_set.add(row.get("label", ""))
    raw_labels = sorted(raw_set)

    # 2) Build mapping to canonical labels
    label_map = build_label_map(raw_labels, canonical_labels)

    # 3) Warn about any raw labels with no canonical match
    unmatched = [
        r for r, m in label_map.items() if m == r and r not in canonical_labels
    ]
    if unmatched:
        print(
            f"[WARNING] No canonical match for these labels: {unmatched}",
            file=sys.stderr,
        )

    # 4) Produce ordered list: canonicals first, then extras
    new_set = set(label_map.values())
    ordered = [lbl for lbl in canonical_labels if lbl in new_set]
    extras = sorted(new_set - set(canonical_labels))
    ordered += extras

    # 5) Write out the labels.py module
    OUT_MODULE.parent.mkdir(parents=True, exist_ok=True)
    with OUT_MODULE.open("w") as f:
        f.write("# AUTOGENERATED from clip_index.csv — do not edit manually\n\n")
        f.write("label_list = [\n")
        for lbl in ordered:
            f.write(f"    {lbl!r},\n")
        f.write("]\n\n")
        f.write("label_map = {\n")
        for raw in raw_labels:
            f.write(f"    {raw!r}: {label_map[raw]!r},\n")
        f.write("}\n")

    print(
        f"[INFO] Generated {OUT_MODULE} with {len(ordered)} labels (including {len(extras)} extras)"
    )


if __name__ == "__main__":
    main()
